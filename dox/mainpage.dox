/*
 * Copyright Philippe Steinmann 2016 - 2020.
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE.txt or copy at
 * https://www.boost.org/LICENSE_1_0.txt)
 */

/*! \mainpage Main
 *
 * \tableofcontents
 *
 * \section introduction Introduction
 *
 * Provides some libraries to read and write simple plain text
 * using the [boost Spirit](https://www.boost.org/doc/libs/1_73_0/libs/spirit/doc/html/index.html) library.
 *
 * It also provides some support to parse QString strings,
 * as well as putting boost Spirit parsers attributes into a QString.
 *
 *
 * \section csv_file_io Reading and writing CSV files
 *
 * \todo Explain the problem of parsing CSV with text fields, also huge files, example of checking if a file contains at least 1 record
 *
 * \todo Write a basic example how to use CsvFileReader with the required includes,
 *   then explain encoding support, finaly same example with QCsvFileReader
 *
 * Some CSV parsers can be used:
 * - Mdt::PlainText::CsvFileReader
 * - Mdt::PlainText::QCsvFileReader,
 *   which also supports reading files that have a different encoding than the machine locale one.
 *
 * \todo Document how to write a custom %CsvFileReader, with int, float, ... fields
 *  Also document some tricks to make rules work, as encountered by CSV grammar.
 *
 * Some CSV parsers can be used:
 * - Mdt::PlainText::CsvFileWriter
 * - Mdt::PlainText::QCsvFileWriter,
 *   which also supports reading files that have a different encoding than the machine locale one.
 *
 * To write CSV files, some fields, like text fields, should be coted in the file,
 * others, like numbers, should not.
 *
 * A possible way to could be to define a custom record, for example:
 * \code
 * struct
 * {
 *   int number,
 *   std::string text
 * };
 * \endcode
 *
 * Then implement a boost Spirit Karma rule,
 * then create a custom CSV file writer using Mdt::PlainText::CsvFileWriterTemplate.
 *
 * A other way could be to convert all our data to its string representation,
 * then use Mdt::PlainText::CsvFileWriter with Mdt::PlainText::CsvGeneratorField,
 * which lets us tell if a field must be quoted or not in the resulting CSV file.
 *
 * \section Qt_support Qt support
 *
 * \todo Explain that Spirit V2 qi uses uint32_t as unicode char
 *
 * \todo Document how to parse QString using BoostSpiritQStringConstIterator,
 * notably using the undocumented unicode namespace for char parsers.
 *
 * \subsection QString_as_container Use QString as output of a parser
 *
 * To be able to use QString as output of a parser:
 * \code
 * include <Mdt/PlainText/BoostSpiritQStringContainer>
 * \endcode
 *
 * \subsection parse_from_QString Parse from a QString
 *
 * - Mdt::PlainText::BoostSpiritQStringConstIterator
 *
 * \subsection parse_file_with_encoding_using_Qt Parse files with encoding support using Qt
 *
 * Qt offers great unicode support, thanks to QString.
 * It is also possible to read sources with various encoding,
 * using QTextCodec and QTextDecoder.
 *
 * - Mdt::PlainText::QTextFileInputConstIterator
 * - Mdt::PlainText::BoostSpiritQTextFileInputConstIterator
 *
 *
 * \section reference Reference
 *
 * \todo ref to classes, ...
 *
 * \section references References
 *
 * \todo CSV 12xx + RFC xxxx here
 *
 * Maybe reference videos:
 *  - James McNellis Unicode in C++
 *  - Thiago String theory
 *
 * \section rationale Rationale
 *
 * \subsection parse_QString_first_attempt Parsing QString sources, first attempt (abandoned)
 *
 * To support parsing QString sources,
 * a attempt was made to create a qchar encoding namespace.
 *
 * \sa [Character Encoding Namespace](https://www.boost.org/doc/libs/1_73_0/libs/spirit/doc/html/spirit/qi/reference/basics.html#spirit.qi.reference.basics.character_encoding_namespace)
 *
 * This was abandoned once trying it with a numeric parser (boost::spirit::ushort_),
 * because it calls explicitly spirit::char_encoding::ascii::tolower(ch).
 * After some time searching a solution, I understood that this is not customisable
 * without rewriting a part of the Boost Spirit library, which of course is a no go.
 *
 * The source code is available in the [qstring-encoding](https://gitlab.com/scandyna/mdtplaintext/-/tree/qstring-encoding)
 * branch:
 * https://gitlab.com/scandyna/mdtplaintext/-/blob/qstring-encoding/libs/PlainText_QtCore/src/Mdt/PlainText/BoostSpiritQStringEncoding.h
 *
 *
 * Also document to use explicit QChar/QString (QLatin1Char, QLatin1String, ..)
 * + warn to compile with
 * -DQT_NO_CAST_DEFINITIONS -DQT_NO_CAST_FROM_ASCII -DQT_NO_CAST_TO_ASCII -DQT_NO_CAST_FROM_BYTEARRAY
 *
 */
